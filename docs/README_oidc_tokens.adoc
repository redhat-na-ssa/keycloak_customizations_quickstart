:scrollbar:
:data-uri:
:toc2:
:linkattrs:

= Token Deep Dive

:numbered:

== Token Introspection

You have a lot of options for introspecting a token.  

=== Acquire Tokens

. View keys of a response from RH-SSO when its `/token` endpoint is invoked:
+
-----
$ curl -X POST "$ACCESS_TOKEN_URL" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "username=jbrown" \
    -d "password=password" \
    -d "grant_type=password" \
    -d "client_id=$SSO_CLIENT_ID" \
    -d "scope=openid" \
    | jq -r 'keys[]'



access_token
expires_in
id_token
not-before-policy
refresh_expires_in
refresh_token
scope
session_state
token_type
-----

. From the listing above, what are the 3 different tokens that are included in the response from the `/token` endpoint ?


. Using the `jbrown` user, retrieve an OAuth2 access token using OAuth2 Resource Owner Password Credentials flow :
+
-----
TKN=$(curl -X POST "$ACCESS_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=jbrown" \
            -d "password=password" \
            -d "grant_type=password" \
            -d "client_id=$SSO_CLIENT_ID" \
            -d "scope=openid" \
            | sed 's/.*access_token":"//g' | sed 's/".*//g')
-----
+
You'll use this `access token` (set to the variable: $TKN) in subsequent sections of this lab.

. As per above, invocation of the `/token` endpoint did not necessitate use of a _client_secret_ data field in the request payload.  Why not ?  What would you need to modify in the SSO client such that _client_secret_ would be required in the request payload ?

=== Introspection
The following discusses several options for introspecting tokens.

==== jwt.io

image::images/jwt_io_option.png[]

==== Command Line

Tokens issued by RH-SSO can be introspected at the command line using the `jq` and `base64` utilities.

. View the JWT header:
+
-----
$ jq -R 'split(".") | .[0] | @base64d | fromjson' <<< $TKN | jq .


{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "mcjna6MSzQQVz6sjI_gOQYj0ByrbDLT7DthD4TnMy2U"
}
-----

. Notice a `typ` of : link:https://datatracker.ietf.org/doc/html/rfc7515[JWT] .
+
The JWT specification requires that the body of the token be encoded in base64.

. View the body of the access token
+
-----
$ jq -R 'split(".") | .[1] | @base64d | fromjson' <<< $TKN | jq .
-----


==== _/token/introspect_ endpoint:

In the previous section, its been quite easy to introspect the header and payloads of tokens from RH-SSO because they are simpley in base64.

If a resource server (or any other client) needs to introspect link:https://auth0.com/docs/secure/tokens/access-tokens#opaque-access-tokens[opaque access tokens] (ie: from some other Identity Provider that issues opaque access tokens), then the token introspect endpoint is the answer. 

Keycloak does expose a `/token/introspect` endpoint that could be (if ever needed ... normally not) invoked as follows: 

-----
$ curl -X POST "$RHSSO_URL/realms/$REALM_ID/protocol/openid-connect/token/introspect" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "client_id=bservice" \
    -d "client_secret=password" \
    -d "token=$TKN" \
    | jq -r .
-----

==== _/userinfo_ endpoint:

-----
$ curl -X GET "$RHSSO_URL/realms/$REALM_ID/protocol/openid-connect/userinfo" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -H "Authorization: Bearer $TKN" \
    | jq -r .

-----

== Token Attributes


== Token Propogation
This section of the lab is based on the following documentation:  link:https://quarkus.io/guides/security-openid-connect[Quarkus: Using OIDC to Protect Service Apps Using Bearer Token Authorization]

Via the _org.eclipse.microprofile.rest.client.propagateHeaders_ system property, Quarkus provides a convenient approach to specify request headers that should be propogated to downstream RESTful services via the REST client.  In this quickstart, this system property is utilzied to propogate the `Authorization` header between backend services.

=== Architecture
In this lab, you'll use the _curl_ utility to smoke test as per the following: 

image::images/quickstart_data_flow.png[]

=== Procedure

. View all users and roles in openldap:
+
-----
$ ldapsearch -x -h localhost -p 3389 -b dc=example,dc=org -D "cn=admin,dc=example,dc=org" -w admin
-----

. Retrieve an OAuth2 _access token_ using OAuth2 link:https://tools.ietf.org/html/rfc6749#section-4.3[Resource Owner Password Credentials] flow :
+
-----
TKN=$(curl -X POST "$ACCESS_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=jbrown" \
            -d "password=password" \
            -d "grant_type=password" \
            -d "client_id=$SSO_CLIENT_ID" \
            -d "scope=openid" \
            | sed 's/.*access_token":"//g' | sed 's/".*//g')

$ echo $TKN
-----
+
NOTE:  By setting a `scope=openid`, the OIDC _id_token_ is also included in the response.

. By setting _fullScopeAllowed=true_ in the SSO client, all roles assocated with an authenticated user will be included in the access token.
+
These roles can be visualized as follows:
+
-----
$ jq -R 'split(".") | .[1] | @base64d | fromjson' <<< $TKN | jq .realm_access.roles

[
  "ldap-user",
  "ldap-admin"
]
-----

. Invoke backend-oidc service directly by including access token in request:
+
-----
$ curl -v -H "Authorization: Bearer $TKN" \
       -H "Accept: text/plain" \
       -X GET $BACKEND_ROUTE/backend/secured


< HTTP/1.1 200 OK
Hello jbrown with roles: ldap-user ldap-admin
-----

. Invoke frontend service (which subsequently invokes the downstream _backend-oidc_ service with _propogated_ request headers): 
+
-----
$ curl -v -H "Authorization: Bearer $TKN" \
       -X GET $FRONTEND_ROUTE/frontend



< HTTP/1.1 200 OK
Hello jbrown with roles: ldap-user ldap-admin
-----

=== Review Questions

. Regarding the value of $ACCESS_TOKEN_URL, what alternative REST endpoint does RH-SSO provide to authenticate as per the OIDC specification ?
.. What is included in the response when invoking that alternative OIDC endpoint ?
.. Under what circumstances should this alternative OIDC endpoint get invoked ?

. What is the configuration used in the _frontend-service_ to instruct it to propagate the _Authorization_ request header to the _backend-service_ ?

. What URL does the _backend-service_ use to configure its _keycloak adapter_ at deployment time ?


/////
Answers:

1) $RHSSO_URL/realms/$REALM_ID/protocol/openid-connect/auth
1.a) authorization code
1.b) single page javascript apps configured to authenticate with RH-SSO using OIDC link:https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow[Authorization Code] flow

2) org.eclipse.microprofile.rest.client.propagateHeaders=Authorization

3) quarkus.oidc.auth-server-url=http://sso:4080/realms/kc-demo
/////

== Client Scoped Mappers

https://keycloak.discourse.group/t/protocol-mappers-alternative-for-keycloak-19/17973
https://github.com/keycloak/keycloak-ui/issues/3342


. Dedicated `non-scoped` mappers (as per the following) will likely be removed in a future release: 
+
image::images/t-inspect-dedicated.png[]

== Offline Tokens

. Enable the `ssoRealmAdmin` user with `offline_access` role:
+
image::images/ssoRealmAdmin_add_offline_role.png[]


. Acquire an offline token: 
+
-----
O_TKN=$(curl -X POST "$ACCESS_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=$REALM_ADMIN" \
            -d "password=$REALM_ADMIN_PASSWD" \
            -d "grant_type=password" \
            -d "client_id=$SSO_CLIENT_ID" \
            -d "scope=openid offline_access" \
            | sed 's/.*refresh_token":"//g' | sed 's/".*//g')

$ echo $O_TKN
-----
+
Notice that authentication was required to acquire this _offline_ token.
From hear on out, subsequent _access_ and _id_ tokens can be acquired with only this _offline_ token.  Authentication will not be needed.

. Notice that the token's type is:  Offline 
+
-----
$ jq -R 'split(".") | .[1] | @base64d | fromjson' <<< $O_TKN | jq -r .typ

Offline
-----
+
Related:  What is the expiration date on your offline token ?

. Creation of an offline token will create records in both the `offline_client_session` and `offline_client_tokens` tables.  These records can be viewed as follows: 

.. Acquire a terminal to the PostgreSQL container corresponding to RH-SSO.

.. At the command line prompt, execute:  `psql sso`

.. At the `psql` prompt, execute the following: 
+
-----
sso=# \x on
Expanded display is on.


sso=# select * from offline_client_session;
-[ RECORD 1 ]-----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
user_session_id         | 3b067a4e-7d4d-4c11-9a4a-913f698b5244
client_id               | 846f5d7b-6be9-4319-800a-b0a1cc9410a2
offline_flag            | 1
timestamp               | 1667315616
data                    | {"authMethod":"openid-connect","notes":{"iss":"http://sso.local:4080/realms/kc-demo","startedAt":"1667315616","level-of-authentication":"-1","scope":"openid offline_access"}}
client_storage_provider | local
external_client_id      | local
-----

.  Using the `offline` token, acquire a new set of tokens using the _grant_type_ of _refresh_token_: 
+
-----
TKN=$( curl -X POST $ACCESS_TOKEN_URL \
       -H "Content-Type: application/x-www-form-urlencoded" \
       -d "grant_type=refresh_token" \
       -d "client_id=$SSO_CLIENT_ID" \
       -d "refresh_token=$O_TKN" \
       | sed 's/.*access_token":"//g' | sed 's/".*//g')
-----

. Notice the expiration date of this access token: 
+
-----
$ TS=$(jq -R 'split(".") | .[1] | @base64d | fromjson' <<< $TKN | jq -r '.exp') && date -d"@$TS"

Tue Nov  1 09:35:54 AM MDT 2022
-----

. While this access token remains valid, use it to invoke any RESTful endpoint of the RH-SSO Admin API: 
+
-----
$ curl -v -X GET \
       -H "Authorization: Bearer $TKN" \
       -H "Accept: application/json" \
       $RHSSO_URL/admin/realms/$REALM_ID/client-scopes | jq -r .
-----

*Next Lab*:  Proceed to the link:README_federation.adoc[RH-SSO User Federation Lab]