:scrollbar:
:data-uri:
:toc2:
:linkattrs:

= Token Propogation & Customization

:numbered:

== Quickstart Highlights



. *OIDC enabled web app development via _docker-compose_*

. *OIDC enabled web app deployment to OpenShift via ansible*

. *OAuth2 and OIDC Token Inspection*

. *Authorization header propogation*
+
Via the _org.eclipse.microprofile.rest.client.propagateHeaders_ system property, Quarkus provides a convenient approach to specify request headers that should be propogated to downstream RESTful services via the REST client.  In this quickstart, this system property is utilzied to propogate the `Authorization` header between backend services.

. *Custom Protocol Mapper and Client Scopes*


== Token Propogation
This section of the lab is based on the following documentation:  link:https://quarkus.io/guides/security-openid-connect[Quarkus: Using OIDC to Protect Service Apps Using Bearer Token Authorization]

=== Architecture
In this lab, you'll use the _curl_ utility to smoke test as per the following: 

image::images/quickstart_data_flow.png[]

=== Procedure

. View all users and roles in openldap:
+
-----
$ ldapsearch -x -h localhost -p 3389 -b dc=example,dc=org -D "cn=admin,dc=example,dc=org" -w admin
-----

. Retrieve an OAuth2 _access token_ using OAuth2 link:https://tools.ietf.org/html/rfc6749#section-4.3[Resource Owner Password Credentials] flow :
+
-----
TKN=$(curl -X POST "$ACCESS_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=jbrown" \
            -d "password=password" \
            -d "grant_type=password" \
            -d "client_id=$SSO_CLIENT_ID" \
            -d "scope=openid" \
            | sed 's/.*access_token":"//g' | sed 's/".*//g')

$ echo $TKN
-----
+
NOTE:  By setting a `scope=openid`, the OIDC _id_token_ is also included in the response.

. By setting _fullScopeAllowed=true_ in the SSO client, all roles assocated with an authenticated user will be included in the access token.
+
These roles can be visualized as follows:
+
-----
$ jq -R 'split(".") | .[1] | @base64d | fromjson' <<< $TKN | jq .realm_access.roles

[
  "ldap-user",
  "ldap-admin"
]
-----

. Invoke backend-oidc service directly by including access token in request:
+
-----
$ curl -v -H "Authorization: Bearer $TKN" \
       -H "Accept: text/plain" \
       -X GET $BACKEND_ROUTE/backend/secured


< HTTP/1.1 200 OK
Hello jbrown with roles: ldap-user ldap-admin
-----

. Invoke frontend service (which subsequently invokes the downstream _backend-oidc_ service with _propogated_ request headers): 
+
-----
$ curl -v -H "Authorization: Bearer $TKN" \
       -X GET $FRONTEND_ROUTE/frontend



< HTTP/1.1 200 OK
Hello jbrown with roles: ldap-user ldap-admin
-----

=== Review Questions

. Regarding the value of $ACCESS_TOKEN_URL, what alternative REST endpoint does RH-SSO provide to authenticate as per the OIDC specification ?
.. What is included in the response when invoking that alternative OIDC endpoint ?
.. Under what circumstances should this alternative OIDC endpoint get invoked ?

. What is the configuration used in the _frontend-service_ to instruct it to propagate the _Authorization_ request header to the _backend-service_ ?

. What URL does the _backend-service_ use to configure its _keycloak adapter_ at deployment time ?


/////
Answers:

1) $RHSSO_URL/realms/$REALM_ID/protocol/openid-connect/auth
1.a) authorization code
1.b) single page javascript apps configured to authenticate with RH-SSO using OIDC link:https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow[Authorization Code] flow

2) org.eclipse.microprofile.rest.client.propagateHeaders=Authorization

3) quarkus.oidc.auth-server-url=http://sso:4080/realms/kc-demo
/////

== Offline Tokens

. Enable the `ssoRealmAdmin` user with `offline_access` role:
+
image::images/ssoRealmAdmin_add_offline_role.png[]


. Acquire an offline token: 
+
-----
O_TKN=$(curl -X POST "$ACCESS_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=$REALM_ADMIN" \
            -d "password=$REALM_ADMIN_PASSWD" \
            -d "grant_type=password" \
            -d "client_id=$SSO_CLIENT_ID" \
            -d "scope=openid offline_access" \
            | sed 's/.*refresh_token":"//g' | sed 's/".*//g')

$ echo $O_TKN
-----
+
Notice that authentication was required to acquire this _offline_ token.
From hear on out, subsequent _access_ and _id_ tokens can be acquired with only this _offline_ token.  Authentication will not be needed.

. Notice that the token's type is:  Offline 
+
-----
$ jq -R 'split(".") | .[1] | @base64d | fromjson' <<< $O_TKN | jq -r .typ

Offline
-----
+
Related:  What is the expiration date on your offline token ?

. Creation of an offline token will create records in both the `offline_client_session` and `offline_client_tokens` tables.  These records can be viewed as follows: 

.. Acquire a terminal to the PostgreSQL container corresponding to RH-SSO.

.. At the command line prompt, execute:  `psql sso`

.. At the `psql` prompt, execute the following: 
+
-----
sso=# \x on
Expanded display is on.


sso=# select * from offline_client_session;
-[ RECORD 1 ]-----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
user_session_id         | 3b067a4e-7d4d-4c11-9a4a-913f698b5244
client_id               | 846f5d7b-6be9-4319-800a-b0a1cc9410a2
offline_flag            | 1
timestamp               | 1667315616
data                    | {"authMethod":"openid-connect","notes":{"iss":"http://sso.local:4080/realms/kc-demo","startedAt":"1667315616","level-of-authentication":"-1","scope":"openid offline_access"}}
client_storage_provider | local
external_client_id      | local
-----

.  Using the `offline` token, acquire a new set of tokens using the _grant_type_ of _refresh_token_: 
+
-----
TKN=$( curl -X POST $ACCESS_TOKEN_URL \
       -H "Content-Type: application/x-www-form-urlencoded" \
       -d "grant_type=refresh_token" \
       -d "client_id=$SSO_CLIENT_ID" \
       -d "refresh_token=$O_TKN" \
       | sed 's/.*access_token":"//g' | sed 's/".*//g')
-----

. Notice the expiration date of this access token: 
+
-----
$ TS=$(jq -R 'split(".") | .[1] | @base64d | fromjson' <<< $TKN | jq -r '.exp') && date -d"@$TS"

Tue Nov  1 09:35:54 AM MDT 2022
-----

. While this access token remains valid, use it to invoke any RESTful endpoint of the RH-SSO Admin API: 
+
-----
$ curl -v -X GET \
       -H "Authorization: Bearer $TKN" \
       -H "Accept: application/json" \
       $RHSSO_URL/admin/realms/$REALM_ID/client-scopes | jq -r .
-----

== Custom Protocol Mapper

=== Protocol Mapper code
. Review the source code for the link:../lucky-number-mapper[Lucky Number Project] project.
+
Thank you link:https://www.n-k.de/[Niko KÃ¶bler] for this excellent link:https://github.com/dasniko/keycloak-tokenmapper-example[example]!

. Review the link:https://github.com/redhat-na-ssa/keycloak_customizations_quickstart/blob/main/etc/sso/Dockerfile[Dockerfile] for the RH-SSO container image.
+
Notice the inclusion of the compiled project jar file in the `/opt/keycloak/providers` directory:
+
-----
...

COPY etc/sso/providers/org.acme-lucky-number-mapper-0.0.1.jar /opt/keycloak/providers/org.acme-lucky-number-mapper-0.0.1.jar

...
-----

. Log in as a site admin to the _Master_ realm of RH-SSO.
. Navigate to the `Provider Info` tab and scroll down to the _protocol-mapper_ section.
. Notice the include of the _oidc-lucky-number-mapper_ entry:
+
image::images/lucky_number_provider_list.png[]

=== Create Client Scope

. In the console of your RH-SSO, navigate to: `kc-demo -> Client Scopes`
. Click `Create client scope`.
. Populate the form as follows: 
.. *Name*: luckyNumber
.. *Description*: Lucky Number generator
.. *Type*: Optional
+
An SSO client will need to explicity include this claim in the list of `scopes` in the token request.  If set to `Default`, this claim would not be required in the list of `scopes` in the token request.
+
NOTE:  The value of this field can be over-written when configuring `client scopes` for a specific SSO client.
.. *Protocol*: openid-connect
.. *Display On Consent Screen*:  ON
.. *Consent Screen Text*: Authorize addition of luckyNumber to tokens
.. *Include in Token Scope*:  ON
.. *Display Order*: 1
. 
Click Save.

. In the *Mappers* tab of the subsequent page, click `Configure a new mapper`
. Select `Lucky Number` and fill in the form to create a _luckyNumber_ protocol mapper
+
image::images/luckyNumber_mapper.png[]

. Click: `Save`

You have now created a client scope that can be re-used across all SSO clients.  
In addition, the user will now have the ability to consent to inclusion of a _luckyNumber_ claim in tokens consumed by downstream clients.  

This latter functionality is known as _OAuth2 scopes_.
You can find an excellent discussion of _OAuth2 scopes_ in chapter 8 of the book: link:https://smile.amazon.com/Keycloak-Management-Applications-protocols-applications-ebook-dp-B092KP135B/dp/B092KP135B/ref=mt_other?_encoding=UTF8&me=&qid=1652368580[Keycloak - Identity and Access Management for Modern Applications]

=== Add _Client Scope_ to SSO client

. Navigate to: `kc-demo -> Clients -> t-inspect -> Settings`
. In the _Settings_ tab, enable `Consent Required`.  Click `Save`.
. Switch to the _Client Scopes -> Setup_ tabs
. Click `Add client scope`, select `luckyNumber` and click `Add -> Optional`.
+
image::images/add_client_scope.png[]

. Notice that `luckyNumber` is now included in the list of `Client Scopes`.

=== Verify _luckyNumber_ claim

. Navigate to the `Clients -> t-inspect -> Client Scopes -> Evaluate`
. In the `User` text box, enter: `jbrown`
+
image::images/evaluate_jbrown_token.png[]

. Notice that in the `Effictive protocol mappers` view, there are about 27 mappers included, but none of them are `luckyNumber`.

. Switch to the `Generated access token` view and again notice the absence of a `luckyNumber` claim.

. From the `Scope parameter` drop down, select `luckyNumber`
+
Notice that a `luckyNumber` claim now appears on the token:
+
image::images/generated_luckyNumber.png[]

== User Consent of new Claim

. In the SSO Admin Console, navitate to the `Settings` tab of the `t-inspect` SSO client.
. Turn on `Consent Required` and then`Save` your changes.
. In a new private browser tab, navigate to the `Token Inspector` webapp and login with the following credentials: 
.. *userId*:  jbrown
.. *Password*: password

. Notice you are prompted to grant access of various user attribute claims: 
+
image::images/oauth_scope_consent.png[]

.. What about the `luckyNumber` claim ?
.. In the browser tab with your RH-SSO admin console, navigate to: `Clients -> t-inspect -> Client Scopes`.
.. Notice the `Assigned type` on the `luckyNumber` client scope is set to `Optional`.  Switch this to `Default`.
.. In the `token-inspector` app, re-login as the `jbrown` user.  Do you now see `luckyNumber` as a claim to grant access to ?
. In the `token-inspect` app, click the `IDToken` tab and notice the inclusion of a _luckyNumber_: 
+
image::images/token_with_luckyNumber.png[]

. In the browser tab of your RH-SSO admin console, navigate to the `consents` page of the `jbrown` user.
+
image::images/jbrown_consent.png[]

. Logout as the `jbrown` user in the `token inspector` app.  Re-login and notice that you are not prompted to consent to granting access to claims.  Why ?
+
In the RH-SSO Admin Console, revoke the existing consent and re-log into the `token inspector` app.  Notice that you are now prompted to once again grant access to various consents. 

== OIDC Logout

When `picture` claim is included in ID Token, the logout flow breaks.
The reason for this is because upon attempted logout, the redirect request from the browser includes a query parameter of `id_token_hint`.  The value of this field is the `id token`.  When the `picture` claim in included in the ID Token, the max size of the request header is exceeded and subsequently, the following error is returned: 

-----
414 Request-URI Too Long
-----

Not that this is a satisfactory fix, but to alleviate the problem by modifying the `type` on the `picture` client-scope for the `t-inspect` SSO client.  Observe the change in logout behavior.

== Custom Authenticator
This exercise is inspired by the following blog post: link:https://www.janua.fr/transient-sessions-in-keycloak/[Transient sessions in Keycloak].  Thank you!

=== Review `transient-authn` project

. Review the source code of the link:../transient-authn[transient-authn] project.
+
Answer the following questions: 


. Review the link:../etc/sso/Dockerfile[Dockerfile] used to create your RH-SSO container.
+
Notice the jar file that includes the compiled `transient-authn` classes is copied to the directory where keycloak scans for custom providers at build time : 
+
-----
COPY etc/sso/providers/org.acme-transient-authn-0.0.1.jar /opt/keycloak/providers/org.acme-transient-authn-0.0.1.jar
-----

. In the RH-SSO admin console, navigate to the `Provider Info` of the `master` realm:
+
Notice the presence of the `transient-authn` custom authenticator: 
+
image::images/providers_transient_authn.png[]

=== Modify `Direct Grants` AuthN Flow


image::images/transient_direct_grants_flow.png[]

=== Test
. Navigate to the _jbrown_ user in the RH-SSO Admin Console.  Ensure there are zero active sessions.

. Acquire tokens via Direct Access Grant flow using the _bservice_ SSO client:
+
-----
curl -X POST "$ACCESS_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=jbrown" \
            -d "password=password" \
            -d "grant_type=password" \
            -d "client_id=bservice" \
            -d "client_secret=password" \
            -d "scope=openid"
-----

. In the RH-SSO Admin Console, return to the `sessions` tab of the _jbrown_ user.  Are there any sessions associated with that user ?

. Acquire tokens via Direct Access Grant flow using the _t-inspect_ SSO client:
+
-----
curl -X POST "$ACCESS_TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=jbrown" \
            -d "password=password" \
            -d "grant_type=password" \
            -d "client_id=t-inspect" \
            -d "scope=openid"
-----

. In the RH-SSO Admin Console, return to the `sessions` tab of the _jbrown_ user.  Are there now any sessions associated with that user ?

*Next Lab*:  Proceed to the link:README_federation.adoc[RH-SSO User Federation Lab]
